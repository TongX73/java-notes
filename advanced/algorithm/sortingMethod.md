
### **Java排序算法与递归全面总结**

---

### **第一部分：排序算法**

排序算法是最基础和重要的算法之一，其目标是将一组无序的数据元素按照某种规则（如升序或降序）重新排列。

#### **1. 冒泡排序 (Bubble Sort)**

*   **核心思想**：重复地遍历待排序的序列，一次比较两个相邻元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作会重复地进行，直到没有再需要交换的元素，这意味着该序列已经排序完成。
*   **算法步骤**：
    1.  比较相邻的元素。如果第一个比第二个大（升序情况），就交换它们两个。
    2.  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，**最后的元素会是最大的数**。
    3.  针对所有的元素重复以上的步骤，除了最后一个（已经排序好的）。
    4.  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
*   **时间复杂度**：
    *   最好情况（已有序）：O(n) （通过优化可实现）
    *   最坏情况（逆序）：O(n²)
    *   平均情况：O(n²)
*   **空间复杂度**：O(1) （原地排序）
*   **稳定性**：**稳定**（相等元素的相对位置不会改变）。
*   **优点**：实现简单，易于理解。
*   **缺点**：效率非常低，处理大规模数据时几乎不可用。
*   **代码示例（优化版，可提前终止）**：
    ```java
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped; // 优化标志位
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            // 最后i个元素已经排好序，无需再比较
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 本轮发生了交换
                }
            }
            // 如果本轮一次交换都没发生，说明数组已有序，可提前结束
            if (!swapped) {
                break;
            }
        }
    }
    ```

---

#### **2. 选择排序 (Selection Sort)**

*   **核心思想**：每次遍历未排序部分，**找到最小（或最大）的元素**，将其放到已排序序列的末尾。
*   **算法步骤**：
    1.  在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
    2.  从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    3.  重复第二步，直到所有元素均排序完毕。
*   **时间复杂度**：
    *   最好情况：O(n²)
    *   最坏情况：O(n²)
    *   平均情况：O(n²) （无论数据如何，比较次数恒定）
*   **空间复杂度**：O(1) （原地排序）
*   **稳定性**：**不稳定**（例如序列 `[5, 5, 2]`，第一次交换后第一个`5`会被换到`2`的位置，从而跑到第二个`5`之后）。
*   **优点**：思路简单，交换次数少（最多交换 `n-1` 次），对于数据量小且对写入耗时敏感的场景（如Flash存储）有一定价值。
*   **缺点**：效率低下，时间复杂度恒为O(n²)。
*   **代码示例**：
    ```java
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i; // 记录最小元素的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j; // 更新最小元素的索引
                }
            }
            // 将找到的最小元素与第i个位置的元素交换
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
    ```

---

#### **3. 插入排序 (Insertion Sort)**

*   **核心思想**：通过构建有序序列，对于未排序数据，在已排序序列中**从后向前扫描**，找到相应位置并插入。
*   **算法步骤**：
    1.  从第一个元素开始，该元素可以认为已经被排序。
    2.  取出下一个元素，在已经排序的元素序列中从后向前扫描。
    3.  如果该元素（已排序）大于新元素，将该元素移到下一位置。
    4.  重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
    5.  将新元素插入到该位置后。
    6.  重复步骤2~5。
*   **时间复杂度**：
    *   最好情况（已有序）：O(n)
    *   最坏情况（逆序）：O(n²)
    *   平均情况：O(n²)
*   **空间复杂度**：O(1) （原地排序）
*   **稳定性**：**稳定**。
*   **优点**：
    *   实现简单。
    *   对于小规模或基本有序的数据集非常高效。Java中的 `Arrays.sort()` 在处理小数组（小于47）时就会使用插入排序的变体。
*   **缺点**：对于大规模无序数组效率较低。
*   **代码示例**：
    ```java
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        // 从第二个元素开始（下标1）作为要插入的元素
        for (int i = 1; i < n; i++) {
            int key = arr[i]; // 待插入的元素
            int j = i - 1; // 从i的前一个位置开始比较

            // 将比key大的元素都向后挪一位
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            // 此时j=-1或arr[j] <= key，将key插入到j+1的位置
            arr[j + 1] = key;
        }
    }
    ```

---

#### **4. 快速排序 (Quick Sort)**

*   **核心思想**：采用**分治策略 (Divide and Conquer)**。
    1.  **分 (Divide)**：选择一个元素作为**基准 (pivot)**，将序列重新排列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。这个操作称为**分区 (partition)**。分区结束后，该基准就处于数列的中间位置。
    2.  **治 (Conquer)**：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。
*   **算法步骤**：
    1.  从数列中挑出一个元素，称为 “基准”（pivot）。
    2.  进行分区操作：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。
    3.  递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
*   **时间复杂度**：
    *   最好情况（每次分区都很平均）：O(n log n)
    *   平均情况：O(n log n)
    *   最坏情况（每次选的基准都是最大或最小元素）：O(n²) （但可以通过优化选基准策略来极大避免）
*   **空间复杂度**：O(log n) （主要是递归调用栈的空间消耗）
*   **稳定性**：**不稳定**。
*   **优点**：平均效率非常高，是处理大规模数据最快的排序算法之一。内部循环很小。
*   **缺点**：最坏情况性能较差，但可以通过随机化选择pivot来避免。
*   **代码示例（经典实现）**：
    ```java
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // partitionIndex 是分区操作后基准值的正确位置
            int partitionIndex = partition(arr, low, high);

            // 递归排序分区的前半部分和后半部分
            quickSort(arr, low, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        // 选择最右边的元素作为基准（可优化为随机选择或三数取中）
        int pivot = arr[high];
        int i = (low - 1); // 索引i指向小于pivot的区域的末尾

        for (int j = low; j < high; j++) {
            // 如果当前元素小于或等于pivot
            if (arr[j] <= pivot) {
                i++;
                // 交换 arr[i] 和 arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        // 将基准元素交换到它的正确位置（i+1）
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }
    // 调用方式：quickSort(arr, 0, arr.length - 1);
    ```

---

### **第二部分：递归 (Recursion)**

*   **核心思想**：一种解决问题的方法，它把一个问题**分解成一个或多个规模更小的相同问题**，直到问题小到可以用非常简单直接的方式来解决。递归的核心在于**自我调用**。
*   **关键要素**：
    1.  **递归条件 (Recursive Case)**：什么情况下函数需要继续调用自己。
    2.  **基线条件/终止条件 (Base Case/Terminating Condition)**：什么情况下函数直接返回，不再调用自己。**这是防止无限递归的关键。**
*   **优点**：代码简洁、清晰，对于解决一些复杂问题（如树、图的遍历，汉诺塔，分治算法）非常有效。
*   **缺点**：
    *   **栈溢出风险 (Stack Overflow)**：每次递归调用都会在内存的调用栈中push一层信息，深度过大会耗尽栈空间。
    *   **效率可能较低**：函数调用开销大，可能存在大量重复计算（如递归计算斐波那契数列）。
*   **经典示例：计算阶乘 (n!)**
    ```java
    public static int factorial(int n) {
        // 1. 基线条件：0! = 1
        if (n == 0) {
            return 1;
        }
        // 2. 递归条件：n! = n * (n-1)!
        else {
            return n * factorial(n - 1);
        }
    }
    ```
*   **递归在快速排序中的应用**：快速排序是分治策略的完美体现，而**递归是实现分治最自然的方式**。
    *   **分 (Divide)**：`partition` 函数将大问题分解成两个子问题（两个子数组）。
    *   **治 (Conquer)**：`quickSort` 函数递归地调用自己来解决这些子问题。
    *   **合 (Combine)**：由于分区操作后基准点已经在正确位置，且子数组排序后整个数组自然有序，所以不需要额外的“合”的操作。

---

### **总结与对比（排序算法）**

| 算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 | 特点 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **冒泡排序** | O(n²) | O(n) (优化后) | O(n²) | O(1) | 稳定 | 简单，效率低，适合教学 |
| **选择排序** | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 | 交换次数少，效率低 |
| **插入排序** | O(n²) | O(n) | O(n²) | O(1) | 稳定 | 小规模或基本有序时高效 |
| **快速排序** | **O(n log n)** | O(n log n) | O(n²) | O(log n) | 不稳定 | **平均最快**，使用广泛 |

**如何选择？**

1.  **小规模数据 (n < 50)**：**插入排序**是简单排序中性能最好的。
2.  **大规模数据，追求平均效率**：**快速排序**是首选。
3.  **需要稳定性**：如果需求要求稳定排序，则不能使用选择排序和快速排序，可以考虑冒泡或插入（但效率低），或者更高级的**归并排序**（你接下来可能会学到）。
4.  **数据基本有序**：**插入排序**会接近其最好情况O(n)，表现非常好。而快速排序如果选基准不好，可能退化成O(n²)。